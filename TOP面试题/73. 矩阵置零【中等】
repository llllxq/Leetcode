给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。

示例1：
输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]

提示：
m == matrix.length
n == matrix[0].length
1 <= m, n <= 200
-2^31 <= matrix[i][j] <= 2^31 - 1


//方法一：使用标记数组
//时间复杂度：O(mn)
//空间复杂度：O(m+n)
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) { 
        int m=matrix.size(),n=matrix[0].size();
        vector<int> row(m,0),column(n,0);//初始化为0，方便标记
        for(int i=0;i<m;i++){//标记
            for(int j=0;j<n;j++){
                if(matrix[i][j]==0){
                    row[i]=1;
                    column[j]=1;
                }
            }
        }
        for(int i=0;i<m;i++){//修改
            for(int j=0;j<n;j++){
                if(row[i]||column[j])
                    matrix[i][j]=0;
            }
        }
    }
};

//官方法2：使用两个标记变量
//可以用矩阵的第一行和第一列代替方法一中的两个标记数组，以达到 O(1) 的额外空间。但这样会导致原数组的第一行和第一列被修改，无法记录它们是否原本包含 0。因此需要额外使用两个标记变量分别记录第一行和第一列是否原本包含 0。
//时间复杂度：O(mn)
//空间复杂度：O(1)

//方法三：使用一个标记变量
//只使用一个标记变量记录第一列是否原本存在 0。这样，第一列的第一个元素即可以标记第一行是否出现 0。但为了防止每一列的第一个元素被提前更新，需要从最后一行开始，倒序地处理矩阵元素。
//时间复杂度：O(mn)
//空间复杂度：O(1)
